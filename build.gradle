plugins {
	//id "eclipse"
	id "idea"
	id "net.neoforged.moddev.legacyforge" version "2.0.52-beta"
	id "maven-publish"
}

sourceSets {
	main.resources { srcDir "src/generated/resources" }
}

version = mod_version
group = mod_group_id

base {
	archivesName = mod_id
}

java {
	sourceCompatibility = targetCompatibility = JavaVersion.VERSION_17
	toolchain.languageVersion = JavaLanguageVersion.of(17)
}

println "Java: ${System.getProperty "java.version"}, JVM: ${System.getProperty "java.vm.version"} (${System.getProperty "java.vendor"}), Arch: ${System.getProperty "os.arch"}"

neoForge {
	version = "${minecraft_version}-${forge_version}"
	
	runs {
		configureEach {
			logLevel = org.slf4j.event.Level.INFO
		}
		client {
			client()
			sourceSet = sourceSets.main
		}
		client2 {
			client()
			programArguments.addAll("--username", "Dev2")
		}
		gradleOnlyClient {
			client()
			programArguments.addAll("--username", "Dev3")
			ideName = ""
		}
		gradleOnlyClient2 {
			client()
			programArguments.addAll("--username", "Dev4")
			disableIdeRun()
		}
		data {
			data()
			
			//stole this from GTCEuM
			sourceSet = sourceSets.main
			ideName = "Data Generation"
			
			gameDirectory.set(file("run/data"))
			// Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
			programArguments.addAll("--mod", mod_id)
			programArguments.addAll("--all")
			programArguments.addAll("--output", file("src/generated/resources/").getAbsolutePath())
			programArguments.addAll("--existing", file("src/main/resources/").getAbsolutePath())
		}
		server {
			server()
		}
	}
	
	mods {
		"${mod_id}" {
			sourceSet sourceSets.main
		}
	}
	
	parchment {
		minecraftVersion = minecraft_version
		mappingsVersion = parchment_version
	}
	
	/*unitTest {
		enable()
		testedMod = mods.testproject
	}*/
	
	additionalMinecraftArtifacts.put("vanillaDeobfuscated", project.file("build/vanilla.jar"))
}

repositories {
	// Put repositories for dependencies here
	// ForgeGradle automatically adds the Forge maven and Maven Central for you
	
	// If you have mod jar dependencies in ./libs, you can declare them as a repository like so.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html#sub:flat_dir_resolver
	// flatDir {
	//     dir "libs"
	// }
	maven {
		name = "GTCEu Maven"
		url = "https://maven.gtceu.com"
		content {
			includeGroup "com.gregtechceu.gtceu"
		}
	}
	maven {
		name = "Registrate Maven"
		url = "https://maven.tterrag.com/"
	}
	maven {
		name = "LDLib Maven"
		url = "https://maven.firstdarkdev.xyz/snapshots"
	}
	maven {
		name = "TerraformersMC"
		url = "https://maven.terraformersmc.com/"
	}
	maven {
		name = "Modrinth"
		url = "https://api.modrinth.com/maven/"
	}
}

dependencies {
	//testImplementation(enforcedPlatform("org.junit:junit-bom:5.10.2"))
	//testImplementation "org.junit.jupiter:junit-jupiter"
	//testRuntimeOnly "org.junit.platform:junit-platform-launcher"
	//testImplementation "net.neoforged:testframework:${project.forge_version}"
	
	// Example mod dependency with JEI - using fg.deobf() ensures the dependency is remapped to your development mappings
	// The JEI API is declared for compile time use, while the full JEI artifact is used at runtime
	// compileOnly fg.deobf("mezz.jei:jei-${mc_version}-common-api:${jei_version}")
	// compileOnly fg.deobf("mezz.jei:jei-${mc_version}-forge-api:${jei_version}")
	// runtimeOnly fg.deobf("mezz.jei:jei-${mc_version}-forge:${jei_version}")
	
	// Example mod dependency using a mod jar from ./libs with a flat dir repository
	// This maps to ./libs/coolmod-${mc_version}-${coolmod_version}.jar
	// The group id is ignored when searching -- in this case, it is "blank"
	// implementation fg.deobf("blank:coolmod-${mc_version}:${coolmod_version}")
	
	modImplementation("com.gregtechceu.gtceu:gtceu-${minecraft_version}:${gtceu_version}") {transitive = false}
	modImplementation("com.tterrag.registrate:Registrate:${registrate_version}") {transitive = false}
	modImplementation("com.lowdragmc.ldlib:ldlib-forge-${minecraft_version}:${ldlib_version}") {transitive = false}
	
	modRuntimeOnly("dev.emi:emi-forge:${emi_version}+${minecraft_version}")
	modRuntimeOnly("maven.modrinth:jade:${jade_version}")
	
	// For more info:
	// http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
	// http://www.gradle.org/docs/current/userguide/dependency_management.html
}

idea {
	module {
		downloadSources = true
		downloadJavadoc = true
	}
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
// When "copyIdeResources" is enabled, this will also run before the game launches in IDE environments.
// See https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html
tasks.named("processResources", ProcessResources).configure {
	var replaceProperties = [
		minecraft_version: minecraft_version,
		minecraft_version_range: minecraft_version_range,
		parchment_version: parchment_version,
		
		gtceu_version: gtceu_version,
		ldlib_version: ldlib_version,
		registrate_version: registrate_version,
		jade_version: jade_version,
		emi_version: emi_version,
		forge_version: forge_version,
		forge_version_range: forge_version_range,
		loader_version_range: loader_version_range,
		
		mod_id: mod_id,
		mod_name: mod_name,
		mod_license: mod_license,
		mod_version: mod_version,
		mod_authors: mod_authors,
		mod_description: mod_description,
	]
	inputs.properties replaceProperties
	
	filesMatching(["META-INF/mods.toml", "pack.mcmeta"]) {
		expand replaceProperties + [project: project]
	}
}

// Example for how to get properties into the manifest for reading at runtime.
tasks.named("jar", Jar).configure {
	manifest {
		attributes([
			"Specification-Title"     : mod_id,
			"Specification-Vendor"    : mod_authors,
			"Specification-Version"   : "1", // We are version 1 of ourselves
			"Implementation-Title"    : project.name,
			"Implementation-Version"  : project.jar.archiveVersion,
			"Implementation-Vendor"   : mod_authors,
			"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
	}
}

// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing:
// tasks.named("publish").configure {
//     dependsOn "reobfJar"
// }

// Example configuration to allow publishing using the maven-publish plugin
publishing {
	publications {
		maven(MavenPublication) {
			from components.java
		}
	}
	repositories {
		maven {
			url "file://${project.projectDir}/mcmodsrepo"
		}
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = "UTF-8" // Use the UTF-8 charset for Java compilation
	options.release.set(17)
}
